<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quantum Trading ‚Äî About Us</title>
  <style>
    :root {
      --bg1: #041027;
      --bg2: #071021;
      --accent: #7afcff;
      --accent-2: #6de6ff;
      --card: #0f1b2b;
      --text: #e0f7ff;
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      color: var(--text);
      line-height: 1.6;
    }

    header {
      text-align: center;
      padding: 2rem 1rem;
      background: rgba(0,0,0,0.4);
    }

    header h1 {
      font-size: 2.5rem;
      color: var(--accent);
      margin: 0;
    }

    section {
      max-width: 900px;
      margin: 2rem auto;
      background: var(--card);
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }

    section h2 {
      color: var(--accent-2);
      margin-top: 0;
    }

    .sayings {
      margin-top: 1.5rem;
      padding-left: 1.2rem;
      border-left: 3px solid var(--accent-2);
      font-style: italic;
      color: #c7e9ff;
    }

    a {
      color: var(--accent);
      text-decoration: none;
      font-weight: bold;
    }

    a:hover {
      text-decoration: underline;
    }

    footer {
      text-align: center;
      padding: 1rem;
      margin-top: 2rem;
      font-size: 0.9rem;
      background: rgba(0,0,0,0.4);
    }
  </style>
</head>
<body>
  <header>
    <h1>Quantum Trading</h1>
    <p>Next-Gen Intelligence for Smarter Markets</p>
  </header>

  <section>
    <h2>About Us</h2>
    <p>
      Quantum Trading is built on the belief that the future of markets lies at the intersection 
      of advanced technology, mathematics, and human insight. Our mission is to empower traders 
      with cutting-edge tools, AI-driven strategies, and real-time market intelligence.
    </p>
    <p>
      We harness the power of quantum-inspired models, algorithmic trading systems, 
      and data science to deliver clarity in chaotic markets. By combining speed, precision, 
      and deep learning, Quantum Trading creates a smarter way to navigate volatility.
    </p>
    <p>
      Whether you are a beginner seeking guidance or a professional looking for an edge, 
      our vision is to build a community where knowledge, tools, and innovation meet.
    </p>

    <div class="sayings">
      <p>‚ÄúDiscipline is the bridge between goals and results.‚Äù</p>
      <p>‚ÄúIn trading, patience is power, and clarity is wealth.‚Äù</p>
      <p>‚ÄúNumbers don‚Äôt lie ‚Äî but interpretation creates the future.‚Äù</p>
      <p>‚ÄúThe market rewards those who prepare, not those who predict.‚Äù</p>
      <p>‚ÄúQuantum thinking means seeing opportunities where others see noise.‚Äù</p>
      <p>‚ÄúTrade with logic, lead with vision, and success will follow.‚Äù</p>
    </div>
  </section>

  <section>
    <h2>Contact Us</h2>
    <p>
      Got questions, ideas, or want to collaborate? Reach out to us on Telegram: <br />
      üëâ <a href="https://t.me/AnonymWorld1" target="_blank">t.me/AnonymWorld1</a>
    </p>
  </section>

  <footer>
    &copy; 2025 Quantum Trading. All Rights Reserved.
  </footer>
</body>
</html>
<!-- Add-on Script: Ultra-Realistic Alien Fleet with Dynamic Lighting -->
<script>
const shipCanvas = document.createElement('canvas');
shipCanvas.style.position = 'fixed';
shipCanvas.style.inset = '0';
shipCanvas.style.zIndex = '0';
shipCanvas.style.pointerEvents = 'none';
document.body.appendChild(shipCanvas);
const sctx = shipCanvas.getContext('2d');

let sw, sh;
function resizeShips() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  sw = shipCanvas.width = window.innerWidth * dpr;
  sh = shipCanvas.height = window.innerHeight * dpr;
  shipCanvas.style.width = window.innerWidth + 'px';
  shipCanvas.style.height = window.innerHeight + 'px';
  sctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resizeShips);
resizeShips();

class AlienShip {
  constructor(type) {
    this.type = type;
    this.reset();
  }

  reset() {
    this.z = Math.random() * 0.9 + 0.1; // depth
    this.x = (Math.random() - 0.5) * sw;
    this.y = (Math.random() - 0.5) * sh * 0.3;
    this.size = Math.random() * 22 + 18;
    this.speed = Math.random() * 0.025 + 0.01;
    this.rotation = Math.random() * Math.PI * 2;
    this.bank = (Math.random() - 0.5) * 0.5;
    this.trail = [];
    this.thrusterColor = `rgba(${50+Math.random()*205},${50+Math.random()*205},255,0.8)`;
    this.bodyGlow = `rgba(50,255,255,${Math.random()*0.2 + 0.1})`;
  }

  draw() {
    const scale = 1 / this.z;
    const x = sw / 2 + this.x * scale;
    const y = sh / 2 + this.y * scale;
    const s = this.size * scale;
    const alpha = Math.min(1, 1 - this.z);

    // Trail
    this.trail.push({x,y,s});
    if(this.trail.length>35) this.trail.shift();
    sctx.save();
    sctx.lineWidth = 2*scale;
    sctx.strokeStyle = `rgba(0,255,255,${alpha*0.15})`;
    sctx.beginPath();
    this.trail.forEach((t,i)=> i===0 ? sctx.moveTo(t.x,t.y) : sctx.lineTo(t.x,t.y));
    sctx.stroke();
    sctx.restore();

    // Thruster glow with dynamic blur based on speed
    sctx.save();
    const blurAmt = 20*scale*(0.5+this.speed*10);
    sctx.shadowColor = this.thrusterColor;
    sctx.shadowBlur = blurAmt;
    sctx.fillStyle = this.thrusterColor;
    sctx.beginPath();
    sctx.ellipse(x, y + s*0.25, s*0.22, s*0.1, this.rotation, 0, Math.PI*2);
    sctx.fill();
    sctx.restore();

    // Body with dynamic lighting
    sctx.save();
    sctx.globalAlpha = alpha;
    sctx.shadowColor = this.bodyGlow;
    sctx.shadowBlur = 8*scale;
    sctx.strokeStyle = `rgba(0,255,255,${alpha*0.25})`;
    sctx.lineWidth = 1.5;
    sctx.fillStyle = 'black';

    if(this.type===0){ // saucer
      sctx.beginPath();
      sctx.ellipse(x, y, s*0.7, s*0.25, this.rotation+this.bank,0,Math.PI*2);
      sctx.fill();
      sctx.stroke();
    } else if(this.type===1){ // triangular
      sctx.beginPath();
      sctx.moveTo(x, y - s*0.25);
      sctx.lineTo(x - s*0.35, y + s*0.25);
      sctx.lineTo(x + s*0.35, y + s*0.25);
      sctx.closePath();
      sctx.fill();
      sctx.stroke();
    } else if(this.type===2){ // double wing
      sctx.beginPath();
      sctx.ellipse(x, y, s*0.55, s*0.2, this.rotation+this.bank,0,Math.PI*2);
      sctx.fill();
      sctx.stroke();
      sctx.beginPath();
      sctx.moveTo(x - s*0.5, y);
      sctx.lineTo(x, y - s*0.15);
      sctx.lineTo(x, y + s*0.15);
      sctx.closePath();
      sctx.fill();
      sctx.stroke();
      sctx.beginPath();
      sctx.moveTo(x + s*0.5, y);
      sctx.lineTo(x, y - s*0.15);
      sctx.lineTo(x, y + s*0.15);
      sctx.closePath();
      sctx.fill();
      sctx.stroke();
    }
    sctx.restore();
  }

  update() {
    this.z -= this.speed;
    if(this.z <=0.02) this.reset();
    this.draw();
  }
}

// fleet
const ships = [];
for(let i=0;i<10;i++){
  ships.push(new AlienShip(Math.floor(Math.random()*3)));
}

function animateFleet(){
  sctx.clearRect(0,0,sw,sh);

  // subtle light reflection from background blobs
  const grd = sctx.createRadialGradient(sw/2, sh/2, 0, sw/2, sh/2, Math.max(sw,sh));
  grd.addColorStop(0, 'rgba(5,20,35,0.03)');
  grd.addColorStop(1, 'rgba(2,6,12,0.1)');
  sctx.fillStyle = grd;
  sctx.fillRect(0,0,sw,sh);

  ships.forEach(ship => ship.update());
  requestAnimationFrame(animateFleet);
}
animateFleet();
</script>
